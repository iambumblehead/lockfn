// Filename: lockfncaching.js
// Timestamp: 2015.04.10-17:15:34 (last modified)  
// Author(s): Bumblehead (www.bumblehead.com)
//
// gets a value with getValFn, then calls onValFn(err, res)
// multiple requests made to the returned function are served
// a value that is once-only generated by onValFun
// 
// --------------------------------------------------------
// var fncaching = lockfncaching.getNew();
// var onValFn = function (err, val) {
//   console.log(null, val);
// };
// fncaching(onValFn, function getValFn (exitFn) {
//   exitFn(null, 3);
// });
// 
// "null, 3"
//


var lockfncaching = ((typeof module === 'object') ? module : {}).exports = (function (f) {

  var cache = {
    val : undefined,
    isActive : false,
    funcArr : [],

    callFuncArr : function (err, blocks) {
      var that = this, funcArr = that.funcArr;
      that.isActive = false;
      while (funcArr.length) funcArr.pop()(err, blocks);
    },

    // persists the returned value with this object
    cacheVal : function (onValFunc, getValFunc) {
      var that = this, val = that.val;

      that.funcArr.push(onValFunc);
      if (that.isActive === false) {
        that.isActive = val === undefined;
        if (typeof val === 'undefined') {
          getValFunc(function (err, newVal) {
            if (err) return that.callFuncArr(err, newVal);
            that.callFuncArr(err, (that.val = newVal));
          });
        } else {
          that.callFuncArr(null, val);
        }
      }
    }
  };

  // lock = lockfncaching.namespace(function (arg1, arg2, arg3, fn) {
  //   doasync(arg1, arg2, arg3, fn);
  // });
  // 
  // lock(a1, a2, a3, function (err, res) {
  //   console.log(res);
  // });
  //
  // lock(a1, a2, a3, function (err, cachedres) {
  //   console.log(res);
  // })
  f = function (getvalfn) {
     var o = function () {
       var l = arguments.length,
           fn = arguments[--l],
           args = [].slice.call(arguments, 0, l);

       if (typeof fn !== 'function') {
         throw new Error('last param must be function');
       }

       o.lock(fn, function getvfn (exitfn) {
         args.push(exitfn);
         getvalfn.apply(l, args);
       });
     };

    return (o.lock = f.getNew()) && o;
  };

  // lock = lockfncaching.namespace(function (arg1, arg2, arg3_namespace, fn) {
  //   doasync(arg1, arg2, arg3, fn);
  // });
  // 
  // lock(a1, a2, a3, function (err, res) {
  //   console.log(res);
  // });
  //
  // lock(a1, a2, a3, function (err, cachedres) {
  //   console.log(res);
  // })
  f.namespace = function (getvalfn) {
    var o = function () {
      var l = arguments.length,
          fn = arguments[--l],
          name = arguments[--l],
          args = [].slice.call(arguments, 0, ++l);

      if (typeof fn !== 'function') {
        throw new Error('last param must be function');
      } else if (typeof name !== 'string') { 
        throw new Error('name param must be function');           
      }

      o.lock(name, fn, function getvfn (exitfn) {
        args.push(exitfn);
        getvalfn.apply(l, args);
      });
    };

    return (o.lock = f.getNamespaceNew()) && o;    
  };

  f.getNew = function () {
    var that = Object.create(cache);
    that.isActive = false;
    that.funcArr = [];
    that.val = undefined;
    return function (onValFunc, getValFunc) { 
      that.cacheVal(onValFunc, getValFunc); 
    };
  };

  f.getNamespaceCache = (function () {
    return function (namespace, namespacesObj) {
      return namespacesObj[namespace] ||
        (namespacesObj[namespace] = f.getNew());
    };
  }());

  f.getNamespaceNew = function () {
    var namespacesobj = {};
    return function (namespace, onValFunc, getValFunc) { 
      f.getNamespaceCache(namespace, namespacesobj)(onValFunc, getValFunc);
    };
  };

  return f;

}());
